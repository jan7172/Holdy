import SwiftUI
import Combine

// MARK: - Datenmodelle

struct Transaction: Identifiable, Codable {
    let id = UUID()
    let time: Int           // Unix Timestamp (Sekunden)
    let result: Int64       // Satoshis; >0 incoming, <0 outgoing

    var date: Date { Date(timeIntervalSince1970: TimeInterval(time)) }
    var btcValue: Double { Double(result) / 100_000_000.0 }

    private enum CodingKeys: String, CodingKey { case time, result }
}

// blockchain.info
struct RawAddrBI: Codable { let txs: [RawTxBI] }
struct RawTxBI: Codable {
    let time: Int?
    let block_time: Int?
    let result: Int64?
}

// BlockCypher
struct RawAddrBC: Codable { let txs: [RawTxBC] }
struct RawTxBC: Codable {
    let confirmed: String?
    let received: String?
    let inputs: [RawInBC]
    let outputs: [RawOutBC]
}
\≈≈≈struct RawInBC: Codable { let addresses: [String]?, output_value: Int64? }
struct RawOutBC: Codable { let addresses: [String]?, value: Int64? }

// Preise
struct CoinGeckoPrice: Codable { let bitcoin: [String: Double] }           // {"bitcoin":{"eur":...}}
struct CoinbaseSpot: Codable { struct DataObj: Codable { let amount: String }; let data: DataObj } // {"data":{"amount":"..."}}
struct BitstampTicker: Codable { let last: String }                        // {"last":"..."}

// MARK: - Root

struct ContentView: View {
    // Erster-Start-Disclaimer
    @AppStorage("disclaimerAccepted") private var disclaimerAccepted = false

    // Einstellungen – neuer Key mit Default 1000 €
    @AppStorage("freeAllowanceEUR_v2") private var freeAllowanceEUR: Double = 1000.0

    // Address & TX-Daten
    @State private var addresses: [String] = UserDefaults.standard.stringArray(forKey: "addresses") ?? []
    @State private var activeAddress: String? = UserDefaults.standard.string(forKey: "activeAddress")
    @State private var transactions: [Transaction] = []
    @State private var loading = false
    @State private var errorMessage: String?
    @State private var newAddress: String = ""

    // Kursdaten
    @State private var btcPriceEUR: Double? = nil
    @State private var lastPriceUpdate: Date? = nil
    @State private var priceError: String? = nil
    @State private var isFetchingPrice = false

    // UI
    @State private var taxDisplayMode: Int = 0 // 0 = BTC, 1 = EUR
    private let priceTimer = Timer.publish(every: 5, on: .main, in: .common).autoconnect()

    var body: some View {
        ZStack {
            if disclaimerAccepted {
                mainTabs
                    .onAppear {
                        if activeAddress != nil { loadTransactions() }
                        fetchPriceEUR()
                    }
                    .onReceive(priceTimer) { _ in fetchPriceEUR() }
            } else {
                DisclaimerView(disclaimerAccepted: $disclaimerAccepted)
            }
        }
    }

    // MARK: - Tabs

    var mainTabs: some View {
        TabView {
            // Adressen
            VStack {
                Text("BTC-Adressen").font(.title)
                HStack {
                    TextField("Neue Adresse eingeben", text: $newAddress)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .textInputAutocapitalization(.never)
                        .autocorrectionDisabled(true)
                    Button("Speichern") {
                        let trimmed = newAddress.trimmingCharacters(in: .whitespacesAndNewlines)
                        guard !trimmed.isEmpty else { return }
                        if !addresses.contains(trimmed) {
                            addresses.append(trimmed)
                            UserDefaults.standard.set(addresses, forKey: "addresses")
                        }
                        activeAddress = trimmed
                        UserDefaults.standard.set(trimmed, forKey: "activeAddress")
                        newAddress = ""
                        loadTransactions()
                    }
                }
                .padding(.horizontal)

                List {
                    ForEach(addresses, id: \.self) { addr in
                        HStack {
                            Text(addr).lineLimit(1).truncationMode(.middle)
                            Spacer()
                            if addr == activeAddress { Text("Aktiv").foregroundColor(.green) }
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            activeAddress = addr
                            UserDefaults.standard.set(addr, forKey: "activeAddress")
                            loadTransactions()
                        }
                    }
                    .onDelete(perform: deleteAddress)
                }
            }
            .tabItem { Label("Adressen", systemImage: "list.bullet") }

            // Transaktionen
            VStack {
                if let active = activeAddress {
                    Text("Transaktionen für:").font(.headline)
                    Text(active).font(.caption).lineLimit(1).truncationMode(.middle).padding(.bottom, 4)

                    if loading {
                        ProgressView("Lade…")
                    } else if let error = errorMessage {
                        Text("Fehler: \(error)").foregroundColor(.red).padding()
                    } else if transactions.isEmpty {
                        Text("Keine Transaktionen gefunden")
                    } else {
                        List(transactions) { tx in
                            VStack(alignment: .leading, spacing: 4) {
                                Text(tx.date.formatted(date: .long, time: .shortened))
                                    .font(.subheadline)
                                Text(String(format: "%@%.8f BTC",
                                            tx.btcValue >= 0 ? "+" : "",
                                            tx.btcValue))
                                    .foregroundColor(tx.btcValue >= 0 ? .green : .red)
                                Text(isTaxable(tx: tx) ? "Steuerpflichtig (< 365 Tage, eingehend)" : "Steuerfrei")
                                    .font(.caption)
                                    .foregroundColor(isTaxable(tx: tx) ? .red : .green)
                            }
                        }
                    }
                } else {
                    Text("Bitte zuerst eine Adresse auswählen")
                }
            }
            .tabItem { Label("Transaktionen", systemImage: "arrow.up.arrow.down") }

            // Steuern (BTC/EUR)
            VStack(spacing: 16) {
                Picker("Anzeige", selection: $taxDisplayMode) {
                    Text("BTC").tag(0)
                    Text("EUR").tag(1)
                }
                .pickerStyle(.segmented)
                .padding(.horizontal)

                // Basen/Ergebnisse
                let baseBTC = taxableIncomingBTC()                    // Summe < 365 Tage, nur eingehend (BTC)
                let price = btcPriceEUR ?? 0
                let baseEUR = baseBTC * price                         // EUR-Basis aus Kurs
                let netEUR = max(0, baseEUR - freeAllowanceEUR)       // Freibetrag angewandt
                let netBTC: Double? = price > 0 ? netEUR / price : nil

                if taxDisplayMode == 0 {
                    // BTC (nach Freibetrag)
                    Text("Steuerpflichtig (BTC, nach Freibetrag):").font(.title3)
                    if let x = netBTC {
                        Text(String(format: "%.8f BTC", x))
                            .font(.system(size: 32, weight: .semibold))
                            .foregroundColor(x == 0 ? .green : .red)
                        Text("Basis < 365 Tage: \(String(format: "%.8f", baseBTC)) BTC")
                            .font(.footnote).foregroundColor(.secondary)
                        if let p = btcPriceEUR {
                            Text("Kurs: \(currency(p))").font(.footnote).foregroundColor(.secondary)
                        }
                    } else {
                        Text(String(format: "%.8f BTC", baseBTC))
                            .font(.system(size: 32, weight: .semibold))
                            .foregroundColor(.red)
                        Text("Hinweis: Kein Kurs → Freibetrag nicht berücksichtigt.")
                            .font(.footnote).foregroundColor(.secondary)
                    }
                } else {
                    // EUR
                    VStack(spacing: 6) {
                        HStack { Text("Kurs:"); Spacer()
                            if let p = btcPriceEUR { Text(currency(p)).bold() } else { Text("…").foregroundColor(.secondary) }
                        }.padding(.horizontal)
                        HStack { Text("< 365 Tage Summe:"); Spacer()
                            Text(currency(baseEUR)).bold()
                        }.padding(.horizontal)
                        HStack { Text("Freibetrag:"); Spacer()
                            Text(currency(freeAllowanceEUR)).bold()
                        }.padding(.horizontal)
                        Divider().padding(.horizontal)
                        Text("Steuerpflichtig (EUR):").font(.title3)
                        Text(currency(netEUR))
                            .font(.system(size: 32, weight: .semibold))
                            .foregroundColor(netEUR == 0 ? .green : .red)
                        if netEUR == 0 {
                            Text("Aktuell keine Steuer dank >365 Tage / Freibetrag.")
                                .font(.footnote).foregroundColor(.secondary).multilineTextAlignment(.center).padding(.horizontal)
                        }
                    }
                }

                HStack(spacing: 12) {
                    Button { fetchPriceEUR(force: true) } label: { Label("Aktualisieren", systemImage: "arrow.clockwise") }
                        .buttonStyle(.bordered)
                    if let t = lastPriceUpdate {
                        Text("Stand: \(t.formatted(date: .omitted, time: .standard))")
                            .font(.footnote).foregroundColor(.secondary)
                    }
                }
                if let perr = priceError {
                    Text("Kursfehler: \(perr)").font(.footnote).foregroundColor(.orange)
                }
                Spacer()
            }
            .tabItem { Label("Steuern", systemImage: "dollarsign.circle") }

            // Einstellungen
            NavigationView {
                List {
                    Section("Allgemein") {
                        NavigationLink("Steuer-Freibetrag") { AllowanceView(freeAllowanceEUR: $freeAllowanceEUR) }
                    }
                    Section("Info") {
                        NavigationLink("Disclaimer / Info") { DisclaimerDetailView() }
                    }
                }
                .navigationTitle("Einstellungen")
            }
            .tabItem { Label("Einstellungen", systemImage: "gear") }
        }
    }

    // MARK: - Logik / Helper

    func isTaxable(tx: Transaction) -> Bool {
        let days = Calendar.current.dateComponents([.day], from: tx.date, to: Date()).day ?? 0
        return days < 365
    }

    func taxableIncomingBTC() -> Double {
        transactions
            .filter { isTaxable(tx: $0) && $0.result > 0 }
            .map { $0.btcValue }
            .reduce(0, +)
    }

    func currency(_ value: Double, code: String = "EUR") -> String {
        let nf = NumberFormatter()
        nf.numberStyle = .currency
        nf.currencyCode = code
        nf.maximumFractionDigits = 2
        nf.minimumFractionDigits = 2
        return nf.string(from: NSNumber(value: value)) ?? "\(value) \(code)"
    }

    func loadTransactions() {
        guard let addr = activeAddress else { return }
        loading = true
        errorMessage = nil
        transactions = []

        // 1) blockchain.info
        let urlBI = URL(string: "https://blockchain.info/rawaddr/\(addr)?limit=1000&format=json")!
        URLSession.shared.dataTask(with: urlBI) { data, resp, error in
            if let _ = error { self.fetchFromBlockCypher(address: addr); return }
            guard let http = resp as? HTTPURLResponse, let data = data else { self.fetchFromBlockCypher(address: addr); return }
            if http.statusCode == 429 { self.fetchFromBlockCypher(address: addr); return }
            guard (200...299).contains(http.statusCode) else { self.fetchFromBlockCypher(address: addr); return }
            do {
                let raw = try JSONDecoder().decode(RawAddrBI.self, from: data)
                let mapped = raw.txs.compactMap { r -> Transaction? in
                    guard let res = r.result, let t = (r.time ?? r.block_time) else { return nil }
                    return Transaction(time: t, result: res)
                }
                DispatchQueue.main.async { self.transactions = mapped; self.errorMessage = nil; self.loading = false }
            } catch {
                self.fetchFromBlockCypher(address: addr)
            }
        }.resume()
    }

    // 2) Fallback: BlockCypher – Nettobetrag für unsere Adresse berechnen
    func fetchFromBlockCypher(address: String) {
        let url = URL(string: "https://api.blockcypher.com/v1/btc/main/addrs/\(address)/full?limit=50")!
        URLSession.shared.dataTask(with: url) { data, resp, error in
            DispatchQueue.main.async {
                self.loading = false
                if let error = error { self.errorMessage = "Fallback-API Fehler: \(error.localizedDescription)"; return }
                guard let http = resp as? HTTPURLResponse, (200...299).contains(http.statusCode), let data = data else {
                    self.errorMessage = "Fallback: keine/ungültige Antwort"; return
                }
                do {
                    let raw = try JSONDecoder().decode(RawAddrBC.self, from: data)
                    let iso = ISO8601DateFormatter()
                    let addrLower = address.lowercased()
                    let mapped: [Transaction] = raw.txs.compactMap { tx in
                        let ts: Int = {
                            if let c = tx.confirmed, let d = iso.date(from: c) { return Int(d.timeIntervalSince1970) }
                            if let r = tx.received, let d = iso.date(from: r) { return Int(d.timeIntervalSince1970) }
                            return Int(Date().timeIntervalSince1970)
                        }()
                        var inSum: Int64 = 0
                        var outSum: Int64 = 0
                        for o in tx.outputs {
                            if let addrs = o.addresses?.map({ $0.lowercased() }), addrs.contains(addrLower),
                               let v = o.value { inSum += v }
                        }
                        for i in tx.inputs {
                            if let addrs = i.addresses?.map({ $0.lowercased() }), addrs.contains(addrLower),
                               let v = i.output_value { outSum += v }
                        }
                        return Transaction(time: ts, result: inSum - outSum)
                    }
                    self.transactions = mapped
                    self.errorMessage = nil
                } catch {
                    self.errorMessage = "Fallback-Dekodierfehler: \(error.localizedDescription)"
                }
            }
        }.resume()
    }

    // Preis mit Fallbacks + Debounce
    func fetchPriceEUR(force: Bool = false) {
        if isFetchingPrice && !force { return }
        isFetchingPrice = true
        priceError = nil

        func finish(_ value: Double?) {
            if let v = value {
                self.btcPriceEUR = v
                self.lastPriceUpdate = Date()
                self.priceError = nil
            } else if self.btcPriceEUR == nil {
                self.priceError = "Kurs konnte nicht geladen werden"
            }
            self.isFetchingPrice = false
        }

        // 1) CoinGecko
        let gecko = URL(string: "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=eur")!
        URLSession.shared.dataTask(with: gecko) { data, _, _ in
            if let data = data, let v = try? JSONDecoder().decode(CoinGeckoPrice.self, from: data).bitcoin["eur"] {
                DispatchQueue.main.async { finish(v) }
            } else {
                // 2) Coinbase Spot
                let coinbase = URL(string: "https://api.coinbase.com/v2/prices/BTC-EUR/spot")!
                URLSession.shared.dataTask(with: coinbase) { data, _, _ in
                    if let data = data, let obj = try? JSONDecoder().decode(CoinbaseSpot.self, from: data),
                       let v = Double(obj.data.amount) {
                        DispatchQueue.main.async { finish(v) }
                    } else {
                        // 3) Bitstamp
                        let bitstamp = URL(string: "https://www.bitstamp.net/api/v2/ticker/btceur")!
                        URLSession.shared.dataTask(with: bitstamp) { data, _, _ in
                            if let data = data, let obj = try? JSONDecoder().decode(BitstampTicker.self, from: data),
                               let v = Double(obj.last) {
                                DispatchQueue.main.async { finish(v) }
                            } else {
                                DispatchQueue.main.async { finish(nil) }
                            }
                        }.resume()
                    }
                }.resume()
            }
        }.resume()
    }

    func deleteAddress(at offsets: IndexSet) {
        let toDelete = offsets.map { addresses[$0] }
        addresses.remove(atOffsets: offsets)
        UserDefaults.standard.set(addresses, forKey: "addresses")
        if let active = activeAddress, toDelete.contains(active) {
            activeAddress = nil
            UserDefaults.standard.removeObject(forKey: "activeAddress")
            transactions = []
        }
    }
}

// MARK: - Disclaimer (Onboarding)

struct DisclaimerView: View {
    @Binding var disclaimerAccepted: Bool
    @State private var canAccept = false

    var body: some View {
        VStack {
            Text("Nutzungsbedingungen & Haftungsausschluss")
                .font(.title).bold().padding(.top)
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    Text(longProfessionalDisclaimer).font(.body).padding(.horizontal)
                    Color.clear.frame(height: 1).onAppear { canAccept = true } // wird erst am Ende sichtbar
                }
            }
            Text(canAccept ? "Du kannst jetzt akzeptieren." : "Bitte bis zum Ende scrollen, um zu akzeptieren.")
                .font(.footnote).foregroundColor(.secondary).padding(.bottom, 4)
            Button("Akzeptieren") { disclaimerAccepted = true }
                .disabled(!canAccept)
                .padding()
                .background(canAccept ? Color.blue : Color.gray)
                .foregroundColor(.white)
                .cornerRadius(8)
                .padding(.bottom)
        }
    }

    private var longProfessionalDisclaimer: String {
        """
        Willkommen bei Holdy.

        Zweck der App
        -------------
        Holdy unterstützt Nutzer dabei, Kryptowährungstransaktionen zu sichten und eine unverbindliche, vereinfachte Einordnung hinsichtlich möglicher steuerlicher Relevanz vorzunehmen. Die App ersetzt keine Steuer-, Rechts- oder Finanzberatung.

        Keine Beratung, keine Gewähr
        ----------------------------
        Informationen, Auswertungen und Umrechnungen werden automatisiert aus öffentlichen Blockchain-Daten und externen Kursquellen abgeleitet. Es besteht keine Gewähr für Richtigkeit, Vollständigkeit, Aktualität oder dauerhafte Verfügbarkeit. Ergebnisse stellen keine Zusicherung, Empfehlung oder verbindliche Auskunft dar.

        Eigenverantwortung der Nutzer
        -----------------------------
        Nutzer prüfen ihre steuerlichen Pflichten selbst und holen für verbindliche Auskünfte geeignete Fachberatung (z. B. Steuerberatung) oder behördliche Informationen ein. Entscheidungen mit finanziellen oder rechtlichen Konsequenzen dürfen nicht ausschließlich auf Grundlage dieser App getroffen werden.

        Haftungsausschluss
        ------------------
        Das Entwicklerteam von Holdy übernimmt keine Haftung für direkte oder indirekte Schäden, entgangene Gewinne, Datenverluste oder sonstige Nachteile, die aus der Nutzung oder Nichtnutzbarkeit der App entstehen – auch nicht bei fehlerhaften, verspäteten oder nicht verfügbaren Kurs- und Transaktionsdaten.

        Beta-Status
        -----------
        Diese Version befindet sich in der Erprobung (Beta). Funktionen können sich ändern oder eingeschränkt sein. Es besteht kein Anspruch auf bestimmte Funktionalitäten oder Ergebnisse.

        Länderspezifische Besonderheiten
        --------------------------------
        Steuerliche Regelungen unterscheiden sich je nach Rechtsordnung und können sich ändern. Die in Holdy verwendeten Vereinfachungen (z. B. 365-Tage-Regel, Freibetragslogik) sind modellhaft und bilden möglicherweise nicht die individuelle Situation ab.

        Zustimmung
        ----------
        Mit der Nutzung von Holdy bestätigst du, diese Hinweise gelesen und verstanden zu haben, und die App ausschließlich auf eigene Verantwortung zu verwenden.
        """
    }
}

// MARK: - Settings Unterseiten

struct AllowanceView: View {
    @Binding var freeAllowanceEUR: Double
    @State private var temp: String = ""

    var body: some View {
        Form {
            Section {
                TextField("Freibetrag in EUR", text: $temp)
                    .keyboardType(.decimalPad)
                HStack {
                    Button("Auf 1.000 € setzen") { freeAllowanceEUR = 1000; temp = formatted(1000) }
                    Spacer()
                    Text("Aktuell: \(formatted(freeAllowanceEUR))").foregroundColor(.secondary)
                }
            } header: { Text("Steuer-Freibetrag") }
        }
        .navigationTitle("Freibetrag")
        .onAppear { temp = formatted(freeAllowanceEUR) }
        .onChange(of: temp) { new in
            // Locale-sicher: Tausender entfernen, Dezimalpunkt normalisieren
            let dec = Locale.current.decimalSeparator ?? "."
            let grp = Locale.current.groupingSeparator ?? ","
            var s = new.replacingOccurrences(of: grp, with: "")
            if dec != "." { s = s.replacingOccurrences(of: dec, with: ".") }
            if let v = Double(s) { freeAllowanceEUR = v }
        }
    }
    private func formatted(_ v: Double) -> String {
        let nf = NumberFormatter()
        nf.numberStyle = .decimal
        nf.usesGroupingSeparator = false // schlicht
        nf.maximumFractionDigits = 2
        return nf.string(from: NSNumber(value: v)) ?? "\(v)"
    }
}

struct DisclaimerDetailView: View {
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                Text("Disclaimer / Info").font(.largeTitle).bold()
                Text("""
                Holdy dient ausschließlich zu Informationszwecken. Keine Steuer-, Rechts- oder Finanzberatung. \
                Kurs- und Transaktionsdaten können fehlerhaft, unvollständig oder zeitverzögert sein. \
                Nutzung auf eigene Verantwortung; für verbindliche Auskünfte bitte Fachberatung einholen.
                """)
            }
            .padding()
        }
    }
}
